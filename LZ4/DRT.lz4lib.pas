unit DRT.lz4lib;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface
uses DRT.LIBNAME,DRT.xxhashlib;

const
//  LZ4LIB_API = LZ4LIB_VISIBILITY;
  LZ4_VERSION_MAJOR = 1;
  LZ4_VERSION_MINOR = 9;
  LZ4_VERSION_RELEASE = 4;
  LZ4_VERSION_NUMBER = (LZ4_VERSION_MAJOR*100*100+LZ4_VERSION_MINOR*100+LZ4_VERSION_RELEASE);
//  LZ4_LIB_VERSION = LZ4_VERSION_MAJOR0.LZ4_VERSION_MINOR0.LZ4_VERSION_RELEASE;
  LZ4_MEMORY_USAGE_MIN = 10;
  LZ4_MEMORY_USAGE_DEFAULT = 14;
  LZ4_MEMORY_USAGE_MAX = 20;
  LZ4_MEMORY_USAGE = LZ4_MEMORY_USAGE_DEFAULT;
  LZ4_MAX_INPUT_SIZE = $7E000000;
  LZ4_HASHLOG = (LZ4_MEMORY_USAGE-2);
  LZ4_HASHTABLESIZE = (1 shl LZ4_MEMORY_USAGE);
  LZ4_HASH_SIZE_U32 = (1 shl LZ4_HASHLOG);
  LZ4_STREAMSIZE = ((1 shl LZ4_MEMORY_USAGE)+32);
  LZ4HC_CLEVEL_MIN = 3;
  LZ4HC_CLEVEL_DEFAULT = 9;
  LZ4HC_CLEVEL_OPT_MIN = 10;
  LZ4HC_CLEVEL_MAX = 12;
  LZ4HC_DICTIONARY_LOGSIZE = 16;
  LZ4HC_MAXD = (1 shl LZ4HC_DICTIONARY_LOGSIZE);
  LZ4HC_MAXD_MASK = (LZ4HC_MAXD-1);
  LZ4HC_HASH_LOG = 15;
  LZ4HC_HASHTABLESIZE = (1 shl LZ4HC_HASH_LOG);
  LZ4HC_HASH_MASK = (LZ4HC_HASHTABLESIZE-1);
  LZ4_STREAMHCSIZE = 262200;
  LZ4_STREAMSIZE_VOIDP = LZ4_STREAMSIZE / sizeof (Pointer);
  LZ4_STREAMHCSIZE_VOIDP = LZ4_STREAMHCSIZE / sizeof ( Pointer );
  LZ4_STREAMDECODESIZE_U64 =4+Ord(sizeof (Pointer) = 16)*2;
  LZ4_STREAMDECODESIZE =  LZ4_STREAMDECODESIZE_U64*sizeof (UInt64);
  LZ4F_VERSION = 100;
  LZ4F_HEADER_SIZE_MIN = 7;
  LZ4F_HEADER_SIZE_MAX = 19;
  LZ4F_BLOCK_HEADER_SIZE = 4;
  LZ4F_BLOCK_CHECKSUM_SIZE = 4;
  LZ4F_CONTENT_CHECKSUM_SIZE = 4;
  LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH = 5;

type
  // Forward declarations
  PLZ4_stream_t_internal = ^LZ4_stream_t_internal;
  PLZ4_streamDecode_t_internal = ^LZ4_streamDecode_t_internal;
  PLZ4HC_CCtx_internal = ^LZ4HC_CCtx_internal;

  LZ4_i8 = Int8;
  LZ4_byte = UInt8;
  PLZ4_byte = ^LZ4_byte;
  LZ4_u16 = UInt16;
  LZ4_u32 = UInt32;

  LZ4_stream_t_internal = record
    hashTable: array [0..4095] of LZ4_u32;
    currentOffset: LZ4_u32;
    tableType: LZ4_u32;
    dictionary: PLZ4_byte;
    dictCtx: PLZ4_stream_t_internal;
    dictSize: LZ4_u32;
  end;

  LZ4_stream_u = record
    case Integer of
      0: (table: array [0..2051] of Pointer);
      1: (internal_donotuse: LZ4_stream_t_internal);
  end;

  LZ4_streamDecode_t_internal = record
    externalDict: PLZ4_byte;
    extDictSize: NativeUInt;
    prefixEnd: PLZ4_byte;
    prefixSize: NativeUInt;
  end;

  LZ4_streamDecode_u = record
    case Integer of
      0: (table: array [0..3] of UInt64);
      1: (internal_donotuse: LZ4_streamDecode_t_internal);
  end;

  LZ4_stream_t = LZ4_stream_u;
  PLZ4_stream_t = ^LZ4_stream_t;
  LZ4_streamDecode_t = LZ4_streamDecode_u;
  PLZ4_streamDecode_t = ^LZ4_streamDecode_t;

  LZ4HC_CCtx_internal = record
    hashTable: array [0..32767] of LZ4_u32;
    chainTable: array [0..65535] of LZ4_u16;
    &end: PLZ4_byte;
    base: PLZ4_byte;
    dictBase: PLZ4_byte;
    dictLimit: LZ4_u32;
    lowLimit: LZ4_u32;
    nextToUpdate: LZ4_u32;
    compressionLevel: Smallint;
    favorDecSpeed: LZ4_i8;
    dirty: LZ4_i8;
    dictCtx: PLZ4HC_CCtx_internal;
  end;

  LZ4_streamHC_u = record
    case Integer of
      0: (table: array [0..32774] of Pointer);
      1: (internal_donotuse: LZ4HC_CCtx_internal);
  end;

  LZ4_streamHC_t = LZ4_streamHC_u;
  PLZ4_streamHC_t = ^LZ4_streamHC_t;

  PLZ4F_cctx_s = Pointer;
  PPLZ4F_cctx_s = ^PLZ4F_cctx_s;
  PLZ4F_dctx_s = Pointer;
  PPLZ4F_dctx_s = ^PLZ4F_dctx_s;
  PLZ4F_CDict_s = Pointer;
  PPLZ4F_CDict_s = ^PLZ4F_CDict_s;
  PLZ4F_frameInfo_t = ^LZ4F_frameInfo_t;
  PLZ4F_preferences_t = ^LZ4F_preferences_t;
  PLZ4F_compressOptions_t = ^LZ4F_compressOptions_t;
  PLZ4F_decompressOptions_t = ^LZ4F_decompressOptions_t;

  LZ4F_errorCode_t = NativeUInt;

  LZ4F_blockSizeID_t = (
    LZ4F_default = 0,
    LZ4F_max64KB = 4,
    LZ4F_max256KB = 5,
    LZ4F_max1MB = 6,
    LZ4F_max4MB = 7);
  PLZ4F_blockSizeID_t = ^LZ4F_blockSizeID_t;

  LZ4F_blockMode_t = (
    LZ4F_blockLinked = 0,
    LZ4F_blockIndependent = 1);
  PLZ4F_blockMode_t = ^LZ4F_blockMode_t;

  LZ4F_contentChecksum_t = (
    LZ4F_noContentChecksum = 0,
    LZ4F_contentChecksumEnabled = 1);
  PLZ4F_contentChecksum_t = ^LZ4F_contentChecksum_t;

  LZ4F_blockChecksum_t = (
    LZ4F_noBlockChecksum = 0,
    LZ4F_blockChecksumEnabled = 1);
  PLZ4F_blockChecksum_t = ^LZ4F_blockChecksum_t;

  LZ4F_frameType_t = (
    LZ4F_frame = 0,
    LZ4F_skippableFrame = 1);
  PLZ4F_frameType_t = ^LZ4F_frameType_t;

  (*! LZ4F_frameInfo_t :
   *  makes it possible to set or read frame parameters.
   *  Structure must be first init to 0, using memset() or LZ4F_INIT_FRAMEINFO,
   *  setting all parameters to default.
   *  It's then possible to update selectively some parameters *)
  LZ4F_frameInfo_t = record
    blockSizeID: LZ4F_blockSizeID_t;
    blockMode: LZ4F_blockMode_t;
    contentChecksumFlag: LZ4F_contentChecksum_t;
    frameType: LZ4F_frameType_t;
    contentSize: UInt64;
    dictID: Cardinal;
    blockChecksumFlag: LZ4F_blockChecksum_t;
  end;

  (*! LZ4F_preferences_t :
   *  makes it possible to supply advanced compression instructions to streaming interface.
   *  Structure must be first init to 0, using memset() or LZ4F_INIT_PREFERENCES,
   *  setting all parameters to default.
   *  All reserved fields must be set to zero. *)
  LZ4F_preferences_t = record
    frameInfo: LZ4F_frameInfo_t;
    compressionLevel: Integer;
    autoFlush: Cardinal;
    favorDecSpeed: Cardinal;
    reserved: array [0..2] of Cardinal;
  end;

  PLZ4F_cctx = Pointer;
  PPLZ4F_cctx = ^PLZ4F_cctx;
  LZ4F_compressionContext_t = Pointer;
  PLZ4F_compressionContext_t = ^LZ4F_compressionContext_t;

  LZ4F_compressOptions_t = record
    stableSrc: Cardinal;
    reserved: array [0..2] of Cardinal;
  end;

  PLZ4F_dctx = Pointer;
  PPLZ4F_dctx = ^PLZ4F_dctx;
  LZ4F_decompressionContext_t = Pointer;
  PLZ4F_decompressionContext_t = ^LZ4F_decompressionContext_t;

  LZ4F_decompressOptions_t = record
    stableDst: Cardinal;
    reserved: array [0..2] of Cardinal;
  end;

  LZ4F_errorCodes = (
    LZ4F_OK_NoError = 0,
    LZ4F_ERROR_GENERIC = 1,
    LZ4F_ERROR_maxBlockSize_invalid = 2,
    LZ4F_ERROR_blockMode_invalid = 3,
    LZ4F_ERROR_contentChecksumFlag_invalid = 4,
    LZ4F_ERROR_compressionLevel_invalid = 5,
    LZ4F_ERROR_headerVersion_wrong = 6,
    LZ4F_ERROR_blockChecksum_invalid = 7,
    LZ4F_ERROR_reservedFlag_set = 8,
    LZ4F_ERROR_allocation_failed = 9,
    LZ4F_ERROR_srcSize_tooLarge = 10,
    LZ4F_ERROR_dstMaxSize_tooSmall = 11,
    LZ4F_ERROR_frameHeader_incomplete = 12,
    LZ4F_ERROR_frameType_unknown = 13,
    LZ4F_ERROR_frameSize_wrong = 14,
    LZ4F_ERROR_srcPtr_wrong = 15,
    LZ4F_ERROR_decompressionFailed = 16,
    LZ4F_ERROR_headerChecksum_invalid = 17,
    LZ4F_ERROR_contentChecksum_invalid = 18,
    LZ4F_ERROR_frameDecoding_alreadyStarted = 19,
    LZ4F_ERROR_maxCode = 20,
    _LZ4F_dummy_error_enum_for_c89_never_used = 21);
  PLZ4F_errorCodes = ^LZ4F_errorCodes;
  PLZ4F_CDict = Pointer;
  PPLZ4F_CDict = ^PLZ4F_CDict;

const
  LZ4F_INIT_FRAMEINFO : LZ4F_frameInfo_t =(
    blockSizeID: LZ4F_default;
    blockMode: LZ4F_blockLinked;
    contentChecksumFlag: LZ4F_noContentChecksum;
    frameType: LZ4F_frame;
    contentSize: 0;
    dictID: 0;
    blockChecksumFlag: LZ4F_noBlockChecksum
  );
  LZ4F_INIT_PREFERENCES : LZ4F_preferences_t =(
    frameInfo: (
      blockSizeID: LZ4F_default;
      blockMode: LZ4F_blockLinked;
      contentChecksumFlag: LZ4F_noContentChecksum;
      frameType: LZ4F_frame;
      contentSize: 0;
      dictID: 0;
      blockChecksumFlag: LZ4F_noBlockChecksum
    );
    compressionLevel: 0;
    autoFlush: 0;
    favorDecSpeed: 0;
    reserved: (0,0,0);
  );

//  function LZ4_versionNumber(): Integer;
//  external libdrt name _PU+'LZ4_versionNumber';
//
//  function LZ4_versionString(): PUTF8Char;
//  external libdrt name _PU+'LZ4_versionString';
//
//  (*! LZ4_compress_default() :
//   *  Compresses 'srcSize' bytes from buffer 'src'
//   *  into already allocated 'dst' buffer of size 'dstCapacity'.
//   *  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).
//   *  It also runs faster, so it's a recommended setting.
//   *  If the function cannot compress 'src' into a more limited 'dst' budget,
//   *  compression stops *immediately*, and the function result is zero.
//   *  In which case, 'dst' content is undefined (invalid).
//   *      srcSize : max supported value is LZ4_MAX_INPUT_SIZE.
//   *      dstCapacity : size of buffer 'dst' (which must be already allocated)
//   *     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)
//   *                or 0 if compression fails
//   * Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer).
//   *)
//  function LZ4_compress_default(const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer): Integer;
//  external libdrt name _PU+'LZ4_compress_default';

  (*! LZ4_decompress_safe() :
   *  compressedSize : is the exact complete size of the compressed block.
   *  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size.
   * @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)
   *           If destination buffer is not large enough, decoding will stop and output an error code (negative value).
   *           If the source stream is detected malformed, the function will stop decoding and return a negative result.
   * Note 1 : This function is protected against malicious data packets :
   *          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,
   *          even if the compressed block is maliciously modified to order the decoder to do these actions.
   *          In such case, the decoder stops immediately, and considers the compressed block malformed.
   * Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.
   *          The implementation is free to send / store / derive this information in whichever way is most beneficial.
   *          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead.
   *)
  function LZ4_decompress_safe(const src: PUTF8Char; dst: PUTF8Char; compressedSize: Integer; dstCapacity: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_safe';

  (*! LZ4_compressBound() :
      Provides the maximum size that LZ4 compression may output in a "worst case" scenario (input data not compressible)
      This function is primarily useful for memory allocation purposes (destination buffer size).
      Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
      Note that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)
          inputSize  : max supported value is LZ4_MAX_INPUT_SIZE
          return : maximum output size in a "worst case" scenario
                or 0, if input size is incorrect (too large or negative)
   *)
  function LZ4_compressBound(inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressBound';

  (*! LZ4_compress_fast() :
      Same as LZ4_compress_default(), but allows selection of "acceleration" factor.
      The larger the acceleration value, the faster the algorithm, but also the lesser the compression.
      It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
      An acceleration value of "1" is the same as regular LZ4_compress_default()
      Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).
      Values > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c).
   *)
  function LZ4_compress_fast(const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer; acceleration: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_fast';

  (*! LZ4_compress_fast_extState() :
   *  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.
   *  Use LZ4_sizeofState() to know how much memory must be allocated,
   *  and allocate it on 8-bytes boundaries (using `malloc()` typically).
   *  Then, provide this buffer as `void* state` to compression function.
   *)
  function LZ4_sizeofState(): Integer;
  external libdrt name _PU+'LZ4_sizeofState';

  function LZ4_compress_fast_extState(state: Pointer; const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer; acceleration: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_fast_extState';

  (*! LZ4_compress_destSize() :
   *  Reverse the logic : compresses as much data as possible from 'src' buffer
   *  into already allocated buffer 'dst', of size >= 'targetDestSize'.
   *  This function either compresses the entire 'src' content into 'dst' if it's large enough,
   *  or fill 'dst' buffer completely with as much data as possible from 'src'.
   *  note: acceleration parameter is fixed to "default".
   *
   * *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.
   *               New value is necessarily <= input value.
   * @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)
   *           or 0 if compression fails.
   *
   * Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):
   *        the produced compressed content could, in specific circumstances,
   *        require to be decompressed into a destination buffer larger
   *        by at least 1 byte than the content to decompress.
   *        If an application uses `LZ4_compress_destSize()`,
   *        it's highly recommended to update external libdrt name _PU+'t be done or ensured,
   *        the receiving decompression function should provide
   *        a dstCapacity which is > decompressedSize, by at least 1 byte.
   *        See https://github.com/lz4/lz4/issues/859 for details
   *)
  function LZ4_compress_destSize(const src: PUTF8Char; dst: PUTF8Char; srcSizePtr: PInteger; targetDstSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_destSize';

  (*! LZ4_decompress_safe_partial() :
   *  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',
   *  into destination buffer 'dst' of size 'dstCapacity'.
   *  Up to 'targetOutputSize' bytes will be decoded.
   *  The function stops decoding on reaching this objective.
   *  This can be useful to boost performance
   *  whenever only the beginning of a block is required.
   *
   * @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)
   *           If source stream is detected malformed, function returns a negative result.
   *
   *  Note 1 : @return can be < targetOutputSize, if compressed block contains less data.
   *
   *  Note 2 : targetOutputSize must be <= dstCapacity
   *
   *  Note 3 : this function effectively stops decoding on reaching targetOutputSize,
   *           so dstCapacity is kind of redundant.
   *           This is because in older versions of this function,
   *           decoding operation would still write complete sequences.
   *           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,
   *           it could write more bytes, though only up to dstCapacity.
   *           Some "margin" used to be required for this operation to work properly.
   *           Thankfully, this is no longer necessary.
   *           The function nonetheless keeps the same signature, in an effort to preserve API compatibility.
   *
   *  Note 4 : If srcSize is the exact size of the block,
   *           then targetOutputSize can be any value,
   *           including larger than the block's decompressed size.
   *           The function will, at most, generate block's decompressed size.
   *
   *  Note 5 : If srcSize is _larger_ than block's compressed size,
   *           then targetOutputSize **MUST** be <= block's decompressed size.
   *           Otherwise, *silent corruption will occur*.
   *)
  function LZ4_decompress_safe_partial(const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; targetOutputSize: Integer; dstCapacity: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_safe_partial';

  function LZ4_createStream(): PLZ4_stream_t;
  external libdrt name _PU+'LZ4_createStream';

  function LZ4_freeStream(streamPtr: PLZ4_stream_t): Integer;
  external libdrt name _PU+'LZ4_freeStream';

  (*! LZ4_resetStream_fast() : v1.9.0+
   *  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks
   *  (e.g., LZ4_compress_fast_continue()).
   *
   *  An LZ4_stream_t must be initialized once before usage.
   *  This is automatically done when created by LZ4_createStream().
   *  However, should the LZ4_stream_t be simply declared on stack (for example),
   *  it's necessary to initialize it first, using LZ4_initStream().
   *
   *  After init, start any new stream with LZ4_resetStream_fast().
   *  A same LZ4_stream_t can be re-used multiple times consecutively
   *  and compress multiple streams,
   *  provided that it starts each new stream with LZ4_resetStream_fast().
   *
   *  LZ4_resetStream_fast() is much faster than LZ4_initStream(),
   *  but is not compatible with memory regions containing garbage data.
   *
   *  Note: it's only useful to call LZ4_resetStream_fast()
   *        in the context of streaming compression.
   *        The *extState* functions perform their own resets.
   *        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.
   *)
  procedure LZ4_resetStream_fast(streamPtr: PLZ4_stream_t);
  external libdrt name _PU+'LZ4_resetStream_fast';

  (*! LZ4_loadDict() :
   *  Use this function to reference a static dictionary into LZ4_stream_t.
   *  The dictionary must remain available during compression.
   *  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.
   *  The same dictionary will have to be loaded on decompression side for successful decoding.
   *  Dictionary are useful for better compression of small data (KB range).
   *  While LZ4 accept any input as dictionary,
   *  results are generally better when using Zstandard's Dictionary Builder.
   *  Loading a size of 0 is allowed, and is the same as reset.
   * @return : loaded dictionary size, in bytes (necessarily <= 64 KB)
   *)
  function LZ4_loadDict(streamPtr: PLZ4_stream_t; const dictionary: PUTF8Char; dictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_loadDict';

  (*! LZ4_compress_fast_continue() :
   *  Compress 'src' content using data from previously compressed blocks, for better compression ratio.
   * 'dst' buffer must be already allocated.
   *  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.
   *
   * @return : size of compressed block
   *           or 0 if there is an error (typically, cannot fit into 'dst').
   *
   *  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.
   *           Each block has precise boundaries.
   *           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.
   *           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.
   *
   *  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !
   *
   *  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.
   *           Make sure that buffers are separated, by at least one byte.
   *           This construction ensures that each block only depends on previous block.
   *
   *  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.
   *
   *  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed.
   *)
  function LZ4_compress_fast_continue(streamPtr: PLZ4_stream_t; const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer; acceleration: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_fast_continue';

  (*! LZ4_saveDict() :
   *  If last 64KB data cannot be guaranteed to remain available at its current memory location,
   *  save it into a safer place (char* safeBuffer).
   *  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),
   *  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.
   * @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error.
   *)
  function LZ4_saveDict(streamPtr: PLZ4_stream_t; safeBuffer: PUTF8Char; maxDictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_saveDict';

  (*! LZ4_createStreamDecode() and LZ4_freeStreamDecode() :
   *  creation / destruction of streaming decompression tracking context.
   *  A tracking context can be re-used multiple times.
   *)
  function LZ4_createStreamDecode(): PLZ4_streamDecode_t;
  external libdrt name _PU+'LZ4_createStreamDecode';

  function LZ4_freeStreamDecode(LZ4_stream: PLZ4_streamDecode_t): Integer;
  external libdrt name _PU+'LZ4_freeStreamDecode';

  (*! LZ4_setStreamDecode() :
   *  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.
   *  Use this function to start decompression of a new stream of blocks.
   *  A dictionary can optionally be set. Use NULL or size 0 for a reset order.
   *  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.
   * @return : 1 if OK, 0 if error
   *)
  function LZ4_setStreamDecode(LZ4_streamDecode: PLZ4_streamDecode_t; const dictionary: PUTF8Char; dictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_setStreamDecode';

  (*! LZ4_decoderRingBufferSize() : v1.8.2+
   *  Note : in a ring buffer scenario (optional),
   *  blocks are presumed decompressed next to each other
   *  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),
   *  at which stage it resumes from beginning of ring buffer.
   *  When setting such a ring buffer for streaming decompression,
   *  provides the minimum size of this ring buffer
   *  to be compatible with any source respecting maxBlockSize condition.
   * @return : minimum ring buffer size,
   *           or 0 if there is an error (invalid maxBlockSize).
   *)
  function LZ4_decoderRingBufferSize(maxBlockSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decoderRingBufferSize';

  (*! LZ4_decompress_*_continue() :
   *  These decoding functions allow decompression of consecutive blocks in "streaming" mode.
   *  A block is an unsplittable entity, it must be presented entirely to a decompression function.
   *  Decompression functions only accepts one block at a time.
   *  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded.
   *  If less than 64KB of data has been decoded, all the data must be present.
   *
   *  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :
   *  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).
   *    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.
   *    In which case, encoding and decoding buffers do not need to be synchronized.
   *    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.
   *  - Synchronized mode :
   *    Decompression buffer size is _exactly_ the same as compression buffer size,
   *    and follows exactly same update rule (block boundaries at same positions),
   *    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),
   *    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).
   *  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.
   *    In which case, encoding and decoding buffers do not need to be synchronized,
   *    and encoding ring buffer can have any size, including small ones ( < 64 KB).
   *
   *  Whenever these conditions are not possible,
   *  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,
   *  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block.
   *)
  function LZ4_decompress_safe_continue(LZ4_streamDecode: PLZ4_streamDecode_t; const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_safe_continue';

  (*! LZ4_decompress_*_usingDict() :
   *  These decoding functions work the same as
   *  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()
   *  They are stand-alone, and don't need an LZ4_streamDecode_t structure.
   *  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.
   *  Performance tip : Decompression speed can be substantially increased
   *                    when dst == dictStart + dictSize.
   *)
  function LZ4_decompress_safe_usingDict(const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapcity: Integer; const dictStart: PUTF8Char; dictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_safe_usingDict';

  (*! LZ4_initStream() : v1.9.0+
   *  An LZ4_stream_t structure must be initialized at least once.
   *  This is automatically done when invoking LZ4_createStream(),
   *  but it's not when the structure is simply declared on stack (for example).
   *
   *  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.
   *  It can also initialize any arbitrary buffer of sufficient size,
   *  and will @return a pointer of proper type upon initialization.
   *
   *  Note : initialization fails if size and alignment conditions are not respected.
   *         In which case, the function will @return NULL.
   *  Note2: An LZ4_stream_t structure guarantees correct alignment and size.
   *  Note3: Before v1.9.0, use LZ4_resetStream() instead
   *)
  function LZ4_initStream(buffer: Pointer; size: NativeUInt): PLZ4_stream_t;
  external libdrt name _PU+'LZ4_initStream';

  (*! Obsolete compression functions (since v1.7.3) *)
  function LZ4_compress(const src: PUTF8Char; dest: PUTF8Char; srcSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress';

  function LZ4_compress_limitedOutput(const src: PUTF8Char; dest: PUTF8Char; srcSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_limitedOutput';

  function LZ4_compress_withState(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_withState';

  function LZ4_compress_limitedOutput_withState(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_limitedOutput_withState';

  function LZ4_compress_continue(LZ4_streamPtr: PLZ4_stream_t; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_continue';

  function LZ4_compress_limitedOutput_continue(LZ4_streamPtr: PLZ4_stream_t; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_limitedOutput_continue';

  (*! Obsolete decompression functions (since v1.8.0) *)
  function LZ4_uncompress(const source: PUTF8Char; dest: PUTF8Char; outputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_uncompress';

  function LZ4_uncompress_unknownOutputSize(const source: PUTF8Char; dest: PUTF8Char; isize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_uncompress_unknownOutputSize';

  function LZ4_create(inputBuffer: PUTF8Char): Pointer;
  external libdrt name _PU+'LZ4_create';

  function LZ4_sizeofStreamState(): Integer;
  external libdrt name _PU+'LZ4_sizeofStreamState';

  function LZ4_resetStreamState(state: Pointer; inputBuffer: PUTF8Char): Integer;
  external libdrt name _PU+'LZ4_resetStreamState';

  function LZ4_slideInputBuffer(state: Pointer): PUTF8Char;
  external libdrt name _PU+'LZ4_slideInputBuffer';

  (*! Obsolete streaming decoding functions (since v1.7.0) *)
  function LZ4_decompress_safe_withPrefix64k(const src: PUTF8Char; dst: PUTF8Char; compressedSize: Integer; maxDstSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_safe_withPrefix64k';

  function LZ4_decompress_fast_withPrefix64k(const src: PUTF8Char; dst: PUTF8Char; originalSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_fast_withPrefix64k';

  (*! Obsolete LZ4_decompress_fast variants (since v1.9.0) :
   *  These functions used to be faster than LZ4_decompress_safe(),
   *  but this is no longer the case. They are now slower.
   *  This is because LZ4_decompress_fast() doesn't know the input size,
   *  and therefore must progress more cautiously into the input buffer to not read beyond the end of block.
   *  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.
   *  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.
   *
   *  The last remaining LZ4_decompress_fast() specificity is that
   *  it can decompress a block without knowing its compressed size.
   *  Such functionality can be achieved in a more secure manner
   *  by employing LZ4_decompress_safe_partial().
   *
   *  Parameters:
   *  originalSize : is the uncompressed size to regenerate.
   *                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.
   * @return : number of bytes read from source buffer (== compressed size).
   *           The function expects to finish at block's end exactly.
   *           If the source stream is detected malformed, the function stops decoding and returns a negative result.
   *  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.
   *         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.
   *         Also, since match offsets are not validated, match reads from 'src' may underflow too.
   *         These issues never happen if input (compressed) data is correct.
   *         But they may happen if input data is invalid (error or intentional tampering).
   *         As a consequence, use these functions in trusted environments with trusted data **only**.
   *)
  function LZ4_decompress_fast(const src: PUTF8Char; dst: PUTF8Char; originalSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_fast';

  function LZ4_decompress_fast_continue(LZ4_streamDecode: PLZ4_streamDecode_t; const src: PUTF8Char; dst: PUTF8Char; originalSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_fast_continue';

  function LZ4_decompress_fast_usingDict(const src: PUTF8Char; dst: PUTF8Char; originalSize: Integer; const dictStart: PUTF8Char; dictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_decompress_fast_usingDict';

  (*! LZ4_resetStream() :
   *  An LZ4_stream_t structure must be initialized at least once.
   *  This is done with LZ4_initStream(), or LZ4_resetStream().
   *  Consider switching to LZ4_initStream(),
   *  invoking LZ4_resetStream() will trigger deprecation warnings in the future.
   *)
  procedure LZ4_resetStream(streamPtr: PLZ4_stream_t);
  external libdrt name _PU+'LZ4_resetStream';

  (*! LZ4_compress_HC() :
   *  Compress data from `src` into `dst`, using the powerful but slower "HC" algorithm.
   * `dst` must be already allocated.
   *  Compression is guaranteed to succeed if `dstCapacity >= LZ4_compressBound(srcSize)` (see "lz4.h")
   *  Max supported `srcSize` value is LZ4_MAX_INPUT_SIZE (see "lz4.h")
   * `compressionLevel` : any value between 1 and LZ4HC_CLEVEL_MAX will work.
   *                      Values > LZ4HC_CLEVEL_MAX behave the same as LZ4HC_CLEVEL_MAX.
   * @return : the number of bytes written into 'dst'
   *           or 0 if compression fails.
   *)
  function LZ4_compress_HC(const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; dstCapacity: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_HC';

  (*! LZ4_compress_HC_extStateHC() :
   *  Same as LZ4_compress_HC(), but using an externally allocated memory segment for `state`.
   * `state` size is provided by LZ4_sizeofStateHC().
   *  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly).
   *)
  function LZ4_sizeofStateHC(): Integer;
  external libdrt name _PU+'LZ4_sizeofStateHC';

  function LZ4_compress_HC_extStateHC(stateHC: Pointer; const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; maxDstSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_HC_extStateHC';

  (*! LZ4_compress_HC_destSize() : v1.9.0+
   *  Will compress as much data as possible from `src`
   *  to fit into `targetDstSize` budget.
   *  Result is provided in 2 parts :
   * @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)
   *           or 0 if compression fails.
   * `srcSizePtr` : on success, *srcSizePtr is updated to indicate how much bytes were read from `src`
   *)
  function LZ4_compress_HC_destSize(stateHC: Pointer; const src: PUTF8Char; dst: PUTF8Char; srcSizePtr: PInteger; targetDstSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_HC_destSize';

  (*! LZ4_createStreamHC() and LZ4_freeStreamHC() :
   *  These functions create and release memory for LZ4 HC streaming state.
   *  Newly created states are automatically initialized.
   *  A same state can be used multiple times consecutively,
   *  starting with LZ4_resetStreamHC_fast() to start a new stream of blocks.
   *)
  function LZ4_createStreamHC(): PLZ4_streamHC_t;
  external libdrt name _PU+'LZ4_createStreamHC';

  function LZ4_freeStreamHC(streamHCPtr: PLZ4_streamHC_t): Integer;
  external libdrt name _PU+'LZ4_freeStreamHC';

  procedure LZ4_resetStreamHC_fast(streamHCPtr: PLZ4_streamHC_t; compressionLevel: Integer);
  external libdrt name _PU+'LZ4_resetStreamHC_fast';

  function LZ4_loadDictHC(streamHCPtr: PLZ4_streamHC_t; const dictionary: PUTF8Char; dictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_loadDictHC';

  function LZ4_compress_HC_continue(streamHCPtr: PLZ4_streamHC_t; const src: PUTF8Char; dst: PUTF8Char; srcSize: Integer; maxDstSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_HC_continue';

  (*! LZ4_compress_HC_continue_destSize() : v1.9.0+
   *  Similar to LZ4_compress_HC_continue(),
   *  but will read as much data as possible from `src`
   *  to fit into `targetDstSize` budget.
   *  Result is provided into 2 parts :
   * @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)
   *           or 0 if compression fails.
   * `srcSizePtr` : on success, *srcSizePtr will be updated to indicate how much bytes were read from `src`.
   *           Note that this function may not consume the entire input.
   *)
  function LZ4_compress_HC_continue_destSize(LZ4_streamHCPtr: PLZ4_streamHC_t; const src: PUTF8Char; dst: PUTF8Char; srcSizePtr: PInteger; targetDstSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compress_HC_continue_destSize';

  function LZ4_saveDictHC(streamHCPtr: PLZ4_streamHC_t; safeBuffer: PUTF8Char; maxDictSize: Integer): Integer;
  external libdrt name _PU+'LZ4_saveDictHC';

  function LZ4_initStreamHC(buffer: Pointer; size: NativeUInt): PLZ4_streamHC_t;
  external libdrt name _PU+'LZ4_initStreamHC';

  function LZ4_compressHC(const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC';

  function LZ4_compressHC_limitedOutput(const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC_limitedOutput';

  function LZ4_compressHC2(const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2';

  function LZ4_compressHC2_limitedOutput(const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2_limitedOutput';

  function LZ4_compressHC_withStateHC(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC_withStateHC';

  function LZ4_compressHC_limitedOutput_withStateHC(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC_limitedOutput_withStateHC';

  function LZ4_compressHC2_withStateHC(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2_withStateHC';

  function LZ4_compressHC2_limitedOutput_withStateHC(state: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2_limitedOutput_withStateHC';

  function LZ4_compressHC_continue(LZ4_streamHCPtr: PLZ4_streamHC_t; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC_continue';

  function LZ4_compressHC_limitedOutput_continue(LZ4_streamHCPtr: PLZ4_streamHC_t; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC_limitedOutput_continue';

  function LZ4_createHC(const inputBuffer: PUTF8Char): Pointer;
  external libdrt name _PU+'LZ4_createHC';

  function LZ4_slideInputBufferHC(LZ4HC_Data: Pointer): PUTF8Char;
  external libdrt name _PU+'LZ4_slideInputBufferHC';

  function LZ4_freeHC(LZ4HC_Data: Pointer): Integer;
  external libdrt name _PU+'LZ4_freeHC';

  function LZ4_compressHC2_continue(LZ4HC_Data: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2_continue';

  function LZ4_compressHC2_limitedOutput_continue(LZ4HC_Data: Pointer; const source: PUTF8Char; dest: PUTF8Char; inputSize: Integer; maxOutputSize: Integer; compressionLevel: Integer): Integer;
  external libdrt name _PU+'LZ4_compressHC2_limitedOutput_continue';

  function LZ4_sizeofStreamStateHC(): Integer;
  external libdrt name _PU+'LZ4_sizeofStreamStateHC';

  function LZ4_resetStreamStateHC(state: Pointer; inputBuffer: PUTF8Char): Integer;
  external libdrt name _PU+'LZ4_resetStreamStateHC';

  procedure LZ4_resetStreamHC(streamHCPtr: PLZ4_streamHC_t; compressionLevel: Integer);
  external libdrt name _PU+'LZ4_resetStreamHC';

  function LZ4_DECODER_RING_BUFFER_SIZE(mbs : NativeInt):NativeInt; inline;

  function LZ4F_isError(code: LZ4F_errorCode_t): Cardinal;
  external libdrt name _PU+'LZ4F_isError';

  function LZ4F_getErrorName(code: LZ4F_errorCode_t): PUTF8Char;
  external libdrt name _PU+'LZ4F_getErrorName';

  function LZ4F_compressionLevel_max(): Integer;
  external libdrt name _PU+'LZ4F_compressionLevel_max';

  (*! LZ4F_compressFrameBound() :
   *  Returns the maximum possible compressed size with LZ4F_compressFrame() given srcSize and preferences.
   * `preferencesPtr` is optional. It can be replaced by NULL, in which case, the function will assume default preferences.
   *  Note : this result is only usable with LZ4F_compressFrame().
   *         It may also be relevant to LZ4F_compressUpdate() _only if_ no flush() operation is ever performed.
   *)
  function LZ4F_compressFrameBound(srcSize: NativeUInt; const preferencesPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressFrameBound';

  (*! LZ4F_compressFrame() :
   *  Compress an entire srcBuffer into a valid LZ4 frame.
   *  dstCapacity MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
   *  The LZ4F_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default.
   * @return : number of bytes written into dstBuffer.
   *           or an error code if it fails (can be tested using LZ4F_isError())
   *)
  function LZ4F_compressFrame(dstBuffer: Pointer; dstCapacity: NativeUInt; const srcBuffer: Pointer; srcSize: NativeUInt; const preferencesPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressFrame';

  function LZ4F_getVersion(): Cardinal;
  external libdrt name _PU+'LZ4F_getVersion';

  (*! LZ4F_createCompressionContext() :
   * The first thing to do is to create a compressionContext object, which will be used in all compression operations.
   * This is achieved using LZ4F_createCompressionContext(), which takes as argument a version.
   * The version provided MUST be LZ4F_VERSION. It is intended to track potential version mismatch, notably when using DLL.
   * The function will provide a pointer to a fully allocated LZ4F_cctx object.
   * If @return != zero, there was an error during context creation.
   * Object can be released using LZ4F_freeCompressionContext();
   * Note: LZ4F_freeCompressionContext() works with NULL pointers (do nothing).
   *)
  function LZ4F_createCompressionContext(cctxPtr: PPLZ4F_cctx; version: Cardinal): LZ4F_errorCode_t;
  external libdrt name _PU+'LZ4F_createCompressionContext';

  function LZ4F_freeCompressionContext(cctx: PLZ4F_cctx): LZ4F_errorCode_t;
  external libdrt name _PU+'LZ4F_freeCompressionContext';

  (*! LZ4F_compressBegin() :
   *  will write the frame header into dstBuffer.
   *  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
   * `prefsPtr` is optional : you can provide NULL as argument, all preferences will then be set to default.
   * @return : number of bytes written into dstBuffer for the header
   *           or an error code (which can be tested using LZ4F_isError())
   *)
  function LZ4F_compressBegin(cctx: PLZ4F_cctx; dstBuffer: Pointer; dstCapacity: NativeUInt; const prefsPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressBegin';

  (*! LZ4F_compressBound() :
   *  Provides minimum dstCapacity required to guarantee success of
   *  LZ4F_compressUpdate(), given a srcSize and preferences, for a worst case scenario.
   *  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() instead.
   *  Note that the result is only valid for a single invocation of LZ4F_compressUpdate().
   *  When invoking LZ4F_compressUpdate() multiple times,
   *  if the output buffer is gradually filled up instead of emptied and re-used from its start,
   *  one must check if there is enough remaining capacity before each invocation, using LZ4F_compressBound().
   * @return is always the same for a srcSize and prefsPtr.
   *  prefsPtr is optional : when NULL is provided, preferences will be set to cover worst case scenario.
   *  tech details :
   * @return if automatic flushing is not enabled, includes the possibility that internal buffer might already be filled by up to (blockSize-1) bytes.
   *  It also includes frame footer (ending + checksum), since it might be generated by LZ4F_compressEnd().
   * @return doesn't include frame header, as it was already generated by LZ4F_compressBegin().
   *)
  function LZ4F_compressBound(srcSize: NativeUInt; const prefsPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressBound';

  (*! LZ4F_compressUpdate() :
   *  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.
   *  Important rule: dstCapacity MUST be large enough to ensure operation success even in worst case situations.
   *  This value is provided by LZ4F_compressBound().
   *  If this condition is not respected, LZ4F_compress() will fail (result is an errorCode).
   *  After an error, the state is left in a UB state, and must be re-initialized or freed.
   * `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.
   * @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).
   *           or an error code if it fails (which can be tested using LZ4F_isError())
   *)
  function LZ4F_compressUpdate(cctx: PLZ4F_cctx; dstBuffer: Pointer; dstCapacity: NativeUInt; const srcBuffer: Pointer; srcSize: NativeUInt; const cOptPtr: PLZ4F_compressOptions_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressUpdate';

  (*! LZ4F_flush() :
   *  When data must be generated and sent immediately, without waiting for a block to be completely filled,
   *  it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx.
   * `dstCapacity` must be large enough to ensure the operation will be successful.
   * `cOptPtr` is optional : it's possible to provide NULL, all options will be set to default.
   * @return : nb of bytes written into dstBuffer (can be zero, when there is no data stored within cctx)
   *           or an error code if it fails (which can be tested using LZ4F_isError())
   *  Note : LZ4F_flush() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).
   *)
  function LZ4F_flush(cctx: PLZ4F_cctx; dstBuffer: Pointer; dstCapacity: NativeUInt; const cOptPtr: PLZ4F_compressOptions_t): NativeUInt;
  external libdrt name _PU+'LZ4F_flush';

  (*! LZ4F_compressEnd() :
   *  To properly finish an LZ4 frame, invoke LZ4F_compressEnd().
   *  It will flush whatever data remained within `cctx` (like LZ4_flush())
   *  and properly finalize the frame, with an endMark and a checksum.
   * `cOptPtr` is optional : NULL can be provided, in which case all options will be set to default.
   * @return : nb of bytes written into dstBuffer, necessarily >= 4 (endMark),
   *           or an error code if it fails (which can be tested using LZ4F_isError())
   *  Note : LZ4F_compressEnd() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).
   *  A successful call to LZ4F_compressEnd() makes `cctx` available again for another compression task.
   *)
  function LZ4F_compressEnd(cctx: PLZ4F_cctx; dstBuffer: Pointer; dstCapacity: NativeUInt; const cOptPtr: PLZ4F_compressOptions_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressEnd';

  (*! LZ4F_createDecompressionContext() :
   *  Create an LZ4F_dctx object, to track all decompression operations.
   *  The version provided MUST be LZ4F_VERSION.
   *  The function provides a pointer to an allocated and initialized LZ4F_dctx object.
   *  The result is an errorCode, which can be tested using LZ4F_isError().
   *  dctx memory can be released using LZ4F_freeDecompressionContext();
   *  Result of LZ4F_freeDecompressionContext() indicates current state of decompressionContext when being released.
   *  That is, it should be == 0 if decompression has been completed fully and correctly.
   *)
  function LZ4F_createDecompressionContext(dctxPtr: PPLZ4F_dctx; version: Cardinal): LZ4F_errorCode_t;
  external libdrt name _PU+'LZ4F_createDecompressionContext';

  function LZ4F_freeDecompressionContext(dctx: PLZ4F_dctx): LZ4F_errorCode_t;
  external libdrt name _PU+'LZ4F_freeDecompressionContext';

  (*! LZ4F_headerSize() : v1.9.0+
   *  Provide the header size of a frame starting at `src`.
   * `srcSize` must be >= LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH,
   *  which is enough to decode the header length.
   * @return : size of frame header
   *           or an error code, which can be tested using LZ4F_isError()
   *  note : Frame header size is variable, but is guaranteed to be
   *         >= LZ4F_HEADER_SIZE_MIN bytes, and <= LZ4F_HEADER_SIZE_MAX bytes.
   *)
  function LZ4F_headerSize(const src: Pointer; srcSize: NativeUInt): NativeUInt;
  external libdrt name _PU+'LZ4F_headerSize';

  (*! LZ4F_getFrameInfo() :
   *  This function extracts frame parameters (max blockSize, dictID, etc.).
   *  Its usage is optional: user can call LZ4F_decompress() directly.
   *
   *  Extracted information will fill an existing LZ4F_frameInfo_t structure.
   *  This can be useful for allocation and dictionary identification purposes.
   *
   *  LZ4F_getFrameInfo() can work in the following situations :
   *
   *  1) At the beginning of a new frame, before any invocation of LZ4F_decompress().
   *     It will decode header from `srcBuffer`,
   *     consuming the header and starting the decoding process.
   *
   *     Input size must be large enough to contain the full frame header.
   *     Frame header size can be known beforehand by LZ4F_headerSize().
   *     Frame header size is variable, but is guaranteed to be >= LZ4F_HEADER_SIZE_MIN bytes,
   *     and not more than <= LZ4F_HEADER_SIZE_MAX bytes.
   *     Hence, blindly providing LZ4F_HEADER_SIZE_MAX bytes or more will always work.
   *     It's allowed to provide more input data than the header size,
   *     LZ4F_getFrameInfo() will only consume the header.
   *
   *     If input size is not large enough,
   *     aka if it's smaller than header size,
   *     function will fail and return an error code.
   *
   *  2) After decoding has been started,
   *     it's possible to invoke LZ4F_getFrameInfo() anytime
   *     to extract already decoded frame parameters stored within dctx.
   *
   *     Note that, if decoding has barely started,
   *     and not yet read enough information to decode the header,
   *     LZ4F_getFrameInfo() will fail.
   *
   *  The number of bytes consumed from srcBuffer will be updated in *srcSizePtr (necessarily <= original value).
   *  LZ4F_getFrameInfo() only consumes bytes when decoding has not yet started,
   *  and when decoding the header has been successful.
   *  Decompression must then resume from (srcBuffer + *srcSizePtr).
   *
   * @return : a hint about how many srcSize bytes LZ4F_decompress() expects for next call,
   *           or an error code which can be tested using LZ4F_isError().
   *  note 1 : in case of error, dctx is not modified. Decoding operation can resume from beginning safely.
   *  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure.
   *)
  function LZ4F_getFrameInfo(dctx: PLZ4F_dctx; frameInfoPtr: PLZ4F_frameInfo_t; const srcBuffer: Pointer; srcSizePtr: PNativeUInt): NativeUInt;
  external libdrt name _PU+'LZ4F_getFrameInfo';

  (*! LZ4F_decompress() :
   *  Call this function repetitively to regenerate data compressed in `srcBuffer`.
   *
   *  The function requires a valid dctx state.
   *  It will read up to *srcSizePtr bytes from srcBuffer,
   *  and decompress data into dstBuffer, of capacity *dstSizePtr.
   *
   *  The nb of bytes consumed from srcBuffer will be written into *srcSizePtr (necessarily <= original value).
   *  The nb of bytes decompressed into dstBuffer will be written into *dstSizePtr (necessarily <= original value).
   *
   *  The function does not necessarily read all input bytes, so always check value in *srcSizePtr.
   *  Unconsumed source data must be presented again in subsequent invocations.
   *
   * `dstBuffer` can freely change between each consecutive function invocation.
   * `dstBuffer` content will be overwritten.
   *
   * @return : an hint of how many `srcSize` bytes LZ4F_decompress() expects for next call.
   *  Schematically, it's the size of the current (or remaining) compressed block + header of next block.
   *  Respecting the hint provides some small speed benefit, because it skips intermediate buffers.
   *  This is just a hint though, it's always possible to provide any srcSize.
   *
   *  When a frame is fully decoded, @return will be 0 (no more data expected).
   *  When provided with more bytes than necessary to decode a frame,
   *  LZ4F_decompress() will stop reading exactly at end of current frame, and @return 0.
   *
   *  If decompression failed, @return is an error code, which can be tested using LZ4F_isError().
   *  After a decompression error, the `dctx` context is not resumable.
   *  Use LZ4F_resetDecompressionContext() to return to clean state.
   *
   *  After a frame is fully decoded, dctx can be used again to decompress another frame.
   *)
  function LZ4F_decompress(dctx: PLZ4F_dctx; dstBuffer: Pointer; dstSizePtr: PNativeUInt; const srcBuffer: Pointer; srcSizePtr: PNativeUInt; const dOptPtr: PLZ4F_decompressOptions_t): NativeUInt;
  external libdrt name _PU+'LZ4F_decompress';

  (*! LZ4F_resetDecompressionContext() : added in v1.8.0
   *  In case of an error, the context is left in "undefined" state.
   *  In which case, it's necessary to reset it, before re-using it.
   *  This method can also be used to abruptly stop any unfinished decompression,
   *  and start a new one using same context resources. *)
  procedure LZ4F_resetDecompressionContext(dctx: PLZ4F_dctx);
  external libdrt name _PU+'LZ4F_resetDecompressionContext';

  function LZ4F_getErrorCode(functionResult: NativeUInt): LZ4F_errorCodes;
  external libdrt name _PU+'LZ4F_getErrorCode';

  function LZ4F_getBlockSize(p1: Cardinal): NativeUInt;
  external libdrt name _PU+'LZ4F_getBlockSize';

  (*! LZ4_createCDict() :
   *  When compressing multiple messages / blocks using the same dictionary, it's recommended to load it just once.
   *  LZ4_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.
   *  LZ4_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
   * `dictBuffer` can be released after LZ4_CDict creation, since its content is copied within CDict *)
  function LZ4F_createCDict(const dictBuffer: Pointer; dictSize: NativeUInt): PLZ4F_CDict;
  external libdrt name _PU+'LZ4F_createCDict';

  procedure LZ4F_freeCDict(CDict: PLZ4F_CDict);
  external libdrt name _PU+'LZ4F_freeCDict';

  (*! LZ4_compressFrame_usingCDict() :
   *  Compress an entire srcBuffer into a valid LZ4 frame using a digested Dictionary.
   *  cctx must point to a context created by LZ4F_createCompressionContext().
   *  If cdict==NULL, compress without a dictionary.
   *  dstBuffer MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).
   *  If this condition is not respected, function will fail (@return an errorCode).
   *  The LZ4F_preferences_t structure is optional : you may provide NULL as argument,
   *  but it's not recommended, as it's the only way to provide dictID in the frame header.
   * @return : number of bytes written into dstBuffer.
   *           or an error code if it fails (can be tested using LZ4F_isError()) *)
  function LZ4F_compressFrame_usingCDict(cctx: PLZ4F_cctx; dst: Pointer; dstCapacity: NativeUInt; const src: Pointer; srcSize: NativeUInt; const cdict: PLZ4F_CDict; const preferencesPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressFrame_usingCDict';

  (*! LZ4F_compressBegin_usingCDict() :
   *  Inits streaming dictionary compression, and writes the frame header into dstBuffer.
   *  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.
   * `prefsPtr` is optional : you may provide NULL as argument,
   *  however, it's the only way to provide dictID in the frame header.
   * @return : number of bytes written into dstBuffer for the header,
   *           or an error code (which can be tested using LZ4F_isError()) *)
  function LZ4F_compressBegin_usingCDict(cctx: PLZ4F_cctx; dstBuffer: Pointer; dstCapacity: NativeUInt; const cdict: PLZ4F_CDict; const prefsPtr: PLZ4F_preferences_t): NativeUInt;
  external libdrt name _PU+'LZ4F_compressBegin_usingCDict';

  (*! LZ4F_decompress_usingDict() :
   *  Same as LZ4F_decompress(), using a predefined dictionary.
   *  Dictionary is used "in place", without any preprocessing.
   *  It must remain accessible throughout the entire frame decoding. *)
  function LZ4F_decompress_usingDict(dctxPtr: PLZ4F_dctx; dstBuffer: Pointer; dstSizePtr: PNativeUInt; const srcBuffer: Pointer; srcSizePtr: PNativeUInt; const dict: Pointer; dictSize: NativeUInt; const decompressOptionsPtr: PLZ4F_decompressOptions_t): NativeUInt;
  external libdrt name _PU+'LZ4F_decompress_usingDict';
implementation
  function LZ4_DECODER_RING_BUFFER_SIZE(mbs : NativeInt):NativeInt; inline;
  begin
    Result := 65536+14+mbs;
  end;
  end.


